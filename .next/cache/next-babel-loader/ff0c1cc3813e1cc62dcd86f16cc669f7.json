{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { formatDateObject, getDates } from './utils/utils';\n/* eslint-disable no-trailing-spaces */\n\nimport ChartComponent from './base/ChartComponent'; // import d3SelectionMulti from 'd3-selection-multi';\n\nimport D3Locale from '@reuters-graphics/d3-locale';\nimport d3 from './utils/d3';\nimport { interpolateHcl } from 'd3'; // see docs on https://github.com/reuters-graphics/graphics-atlas-client\n// import AtlasMetadataClient from '@reuters-graphics/graphics-atlas-client';\n// const atlastClient = new AtlasMetadataClient();\n// const dateFormat_tt = d3.timeFormat('%B %e');\n// const numberFormat_tt = d3.format(',');\n\nconst dateParse = d3.timeParse('%Y-%m-%d');\n\nclass CountryLockdownIndicatorStrips extends ChartComponent {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"defaultProps\", {\n      locale: 'en',\n      // See docs https://github.com/reuters-graphics/d3-locale\n      // dateSeries: ['2019-12-31', '2020-07-07'], // yyyy-mm-dd format\n      // dataParams: {\n      //   date: 'date',\n      //   index: 'c1',\n      //   stepValue: 'flag',\n      //   steps: 2, // stepValue = 0, 1...\n      // },\n      height: 150,\n      stripHeight: 50,\n      margin: {\n        top: 10,\n        right: 18,\n        bottom: 10,\n        left: 18\n      },\n      valign: 'center',\n      // start, center, baseline\n      baseColor: 'rgba(255,255,255,0.1)',\n      // stripColor: { // should be numeric values that are mapped from the data\n      //   0: 'rgba(255,255,255,0.25)', // '#4C566A',\n      //   1: 'rgba(255,255,255,0.5)',\n      //   2: 'rgba(255,255,255,0.75)',\n      //   3: 'rgba(255,195,195,1)',\n      // },\n      // legendItems: { // should contain items from stripColor\n      //   null: 'no data',\n      //   stepLegend: {\n      //     0: 'targeted',\n      //     1: 'nationwide',\n      //   },\n      //   indexLegend: {\n      //     0: 'no measures',\n      //     1: 'recommend closing',\n      //     2: 'require closing on some levels',\n      //     3: 'require closing all levels',\n      //   },\n      // },\n      // chartTitle: 'School closing measures',\n      axis: true // markDates: ['2019-12-31', '2020-03-25', '2020-07-07'], // yyyy-mm-dddd\n\n    });\n\n    _defineProperty(this, \"defaultData\", []);\n  }\n\n  draw() {\n    const allData = this.data();\n    const props = this.props();\n    const node = this.selection().node(); // date formatters\n\n    const locale = new D3Locale(props.locale);\n    const dateFormat = locale.formatTime('%b %e'); // get date range to be plotted\n\n    if (!props.dateSeries) {\n      props.dateSeries = [dateParse(allData[0].date), dateParse(allData[allData.length - 1].date)];\n    }\n\n    const dateSeries = getDates(props.dateSeries[0], props.dateSeries[1]); // console.log((dateSeries));\n    // set data for the date series\n\n    const data = dateSeries.map(d => {\n      const match = allData.find(e => e[props.dataParams.date] === formatDateObject(d));\n\n      if (match) {\n        return match;\n      } else {\n        const obj = {};\n        obj[props.dataParams.date] = formatDateObject(d);\n        return obj;\n      }\n    }); // console.log(data);\n    // get country details from AtlasClient from ISO-2\n    // props.country = atlastClient.getCountry(props.countryISO2);\n\n    const {\n      width\n    } = node.getBoundingClientRect();\n    const transition = d3.transition().duration(750);\n    const stripheight = props.legendItems ? props.stripHeight - props.margin.top : props.height - props.margin.top - props.margin.bottom; // set scales\n\n    const xScale = d3.scaleBand().domain(dateSeries).range([0, width - props.margin.left - props.margin.right]).padding(0);\n    const yScale = d3.scaleLinear().domain([0, props.dataParams.steps - 1]).range([stripheight / props.dataParams.steps, stripheight]);\n    const colorDomain = props.stripColor ? Object.keys(props.stripColor).map(d => +d) : d3.extent(data.map(d => d[props.dataParams.index]));\n    const colorRange = props.stripColor ? colorDomain.map(d => props.stripColor[`${d}`]) : ['#333333', '#cccccc'];\n    const colorScale = d3.scaleLinear().domain(colorDomain).range(colorRange).interpolate(interpolateHcl); // main chart container\n\n    const chartDiv = this.selection().appendSelect('div') // see docs in ./utils/d3.js\n    .attr('class', 'CountryLockdownIndicatorStrips').style('width', `${width}px`) // .style('height', `${props.height}px`)\n    .appendSelect('div').style('padding-top', `${props.margin.top}px`).style('padding-right', `${props.margin.right}px`).style('padding-bottom', `${props.margin.bottom}px`).style('padding-left', `${props.margin.left}px`); // make bars\n\n    const bars = chartDiv.appendSelect('div.bars-container').style('display', 'flex').style('align-items', `${props.valign}`).style('justify-content', 'center').selectAll('.bar').data(data, (d, i) => d[props.dataParams.date]); // for smooth data updation\n\n    bars.enter().append('div').attr('class', d => `bar ${d[props.dataParams.date]}`).style('display', 'inline-block').style('height', d => {\n      if (isNaN(d[props.dataParams.stepValue])) {\n        return yScale(0) + 'px';\n      } else {\n        return yScale(d[props.dataParams.stepValue]) + 'px';\n      }\n    }).style('width', xScale.bandwidth() + 'px').style('background', d => {\n      const val = parseFloat(d[props.dataParams.index]);\n      return val !== null && !isNaN(val) ? colorScale(val) : props.baseColor;\n    }).merge(bars).transition(transition).style('display', 'inline-block').style('height', d => {\n      if (isNaN(d[props.dataParams.stepValue])) {\n        return yScale(0) + 'px';\n      } else {\n        return yScale(d[props.dataParams.stepValue]) + 'px';\n      }\n    }).style('width', xScale.bandwidth() + 'px').style('background', d => {\n      const val = parseFloat(d[props.dataParams.index]);\n      return val !== null && !isNaN(val) ? colorScale(val) : props.baseColor;\n    });\n    bars.exit().transition(transition).attr('height', 0).remove(); // add axis\n    // console.log(xScale(dateParse('2020-07-07')));\n\n    if (props.axis) {\n      const stepChange = [];\n\n      if (props.dataParams.steps > 1) {\n        for (let i = 1; i < props.dataParams.steps; i++) {\n          const match = data.find(e => e[props.dataParams.stepValue] === i);\n\n          if (match) {\n            stepChange.push(dateParse(match[props.dataParams.date]));\n          }\n        }\n      }\n\n      const markDates = props.markDates ? props.markDates.map(d => {\n        if (!isNaN(xScale(dateParse(d)))) {\n          return dateParse(d);\n        }\n      }).filter(d => !isNaN(d)) : [dateSeries[0], dateSeries.slice(-1)[0]].concat(stepChange); // console.log(markDates);\n\n      const xAxis = chartDiv.appendSelect('svg').attr('width', width - props.margin.left - props.margin.right).attr('height', 25).attr('transform', 'translate(0, 0)');\n      xAxis.appendSelect('g.axis-x').attr('class', 'axis-x axis').transition(transition).attr('transform', 'translate(0,0)').call(d3.axisBottom(xScale).tickValues(markDates).tickFormat(dateFormat));\n    } // add chart title\n\n\n    if (props.chartTitle) {\n      chartDiv.appendSelect('div.chart-title').attr('class', 'font-display chart-title').html(`<h6>${props.chartTitle}</h6>`);\n    } // chart legend\n\n\n    if (props.legendItems) {\n      // make legend\n      const legendDiv = chartDiv.appendSelect('div.legend-container');\n\n      if (props.legendItems.indexLegend) {\n        var indexLegendItems = [];\n        Object.keys(props.legendItems.indexLegend).forEach(d => {\n          const item = {\n            key: d,\n            value: props.legendItems.indexLegend[d]\n          };\n          indexLegendItems.push(item);\n        });\n\n        if (props.legendItems.null) {\n          indexLegendItems.unshift({\n            key: 'null',\n            value: props.legendItems.null\n          });\n        }\n\n        indexLegendItems = indexLegendItems.filter(d => d.value !== 'null' && d.value !== null); // const legendWidth = (width - props.margin.right - props.margin.left) / indexLegendItems.length;\n\n        const indexLegend = legendDiv.appendSelect('div.legend.indexLegend').selectAll('.legend-item').data(indexLegendItems, d => d.key); // for smooth data updation\n\n        indexLegend.enter().append('div').attr('class', d => `legend-item ${d.key}`).style('display', 'flex').style('margin', d => {\n          if (d.key === 'null') {\n            return '1rem 0';\n          }\n        }) // .style('width', `${legendWidth}px`)\n        .html(d => {\n          const color = +d.key !== null && !isNaN(+d.key) ? colorScale(+d.key) : props.baseColor;\n          return `<span style=\"width:1.5rem;min-width:1rem; min-height:1rem; background: ${color}\"></span> <p style=\"margin:0 0 0 0.5rem;\">${d.value}</p>`;\n        }).merge(indexLegend).transition(transition);\n        indexLegend.exit().transition(transition).remove();\n      }\n\n      if (props.legendItems.stepLegend) {\n        // step legend stuff\n        var stepLegendItems = Object.keys(props.legendItems.stepLegend).map(d => {\n          return {\n            key: d,\n            value: props.legendItems.stepLegend[d]\n          };\n        }); // console.log(props.legendItems.stepLegend);\n\n        stepLegendItems = stepLegendItems.filter(d => d.value !== 'null' && d.value !== null);\n        const stepLegend = legendDiv.appendSelect('div.legend.stepLegend').style('align-items', `${props.valign}`).selectAll('.legend-item').data(stepLegendItems, d => d.key); // for smooth data updation\n\n        stepLegend.enter().append('div').attr('class', d => `legend-item ${d.key}`).style('display', 'flex').style('flex-flow', 'column-reverse') // .style('width', `${legendWidth}px`)\n        .html((d, i) => {\n          const stepSize = stripheight / stepLegendItems.length;\n          return `<span style=\"width:100%; height:${(+d.key + 1) * stepSize}px; background-color:${props.baseColor};\"></span><p style=\"margin:0 0.5rem 0.5rem 0.5rem;\">${d.value}</p>`;\n        }).merge(stepLegend).transition(transition);\n        stepLegend.exit().transition(transition).remove();\n      }\n    }\n\n    return this;\n  }\n\n} // console.log(this.defaultProps);\n\n\nexport default CountryLockdownIndicatorStrips;","map":null,"metadata":{},"sourceType":"module"}